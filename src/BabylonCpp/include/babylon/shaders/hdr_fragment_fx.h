#ifndef BABYLON_SHADERS_HDR_FRAGMENT_FX_H
#define BABYLON_SHADERS_HDR_FRAGMENT_FX_H

namespace BABYLON {

extern const char* hdrPixelShader;

const char* hdrPixelShader
  = "uniform sampler2D textureSampler;\n"
    "varying vec2 vUV;\n"
    "\n"
    "#if defined(GAUSSIAN_BLUR_H) || defined(GAUSSIAN_BLUR_V)\n"
    "uniform float blurOffsets[9];\n"
    "uniform float blurWeights[9];\n"
    "uniform float multiplier;\n"
    "\n"
    "void main(void) {\n"
    "  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n"
    "\n"
    "  for (int i = 0; i < 9; i++) {\n"
    "  #ifdef GAUSSIAN_BLUR_H\n"
    "  color += (texture2D(textureSampler, vUV + vec2(blurOffsets[i] * multiplier, 0.0)) * blurWeights[i]);\n"
    "  #else\n"
    "  color += (texture2D(textureSampler, vUV + vec2(0.0, blurOffsets[i] * multiplier)) * blurWeights[i]);\n"
    "  #endif\n"
    "  }\n"
    "\n"
    "  color.a = 1.0;\n"
    "  gl_FragColor = color;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(TEXTURE_ADDER)\n"
    "uniform sampler2D otherSampler;\n"
    "\n"
    "void main() {\n"
    "  vec4 sum = texture2D(textureSampler, vUV) + texture2D(otherSampler, vUV);\n"
    "  sum.a = clamp(sum.a, 0.0, 1.0);\n"
    "\n"
    "  gl_FragColor = sum;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(LUMINANCE_GENERATOR)\n"
    "uniform vec2 lumOffsets[4];\n"
    "\n"
    "void main() {\n"
    "  float average = 0.0;\n"
    "  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n"
    "  float maximum = -1e20;\n"
    "\n"
    "  for (int i = 0; i < 4; i++) {\n"
    "  color = texture2D(textureSampler, vUV + lumOffsets[i]);\n"
    "\n"
    "  float GreyValue = length(color.rgb);\n"
    "\n"
    "  maximum = max(maximum, GreyValue);\n"
    "  average += (0.25 * log(1e-5 + GreyValue));\n"
    "  }\n"
    "\n"
    "  average = exp(average);\n"
    "\n"
    "  gl_FragColor = vec4(average, maximum, 0.0, 1.0);\n"
    "\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(DOWN_SAMPLE)\n"
    "uniform vec2 dsOffsets[9];\n"
    "uniform float halfDestPixelSize;\n"
    "\n"
    "#ifdef FINAL_DOWN_SAMPLE\n"
    "vec4 pack(float value) {\n"
    "  const vec4 bit_shift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\n"
    "  const vec4 bit_mask = vec4(0.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n"
    "\n"
    "  vec4 res = fract(value * bit_shift);\n"
    "  res -= res.xxyz * bit_mask;\n"
    "\n"
    "  return res;\n"
    "}\n"
    "#endif\n"
    "\n"
    "void main() {\n"
    "  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n"
    "  float average = 0.0;\n"
    "\n"
    "  for (int i = 0; i < 9; i++) {\n"
    "  color = texture2D(textureSampler, vUV + vec2(halfDestPixelSize, halfDestPixelSize) + dsOffsets[i]);\n"
    "  average += color.r;\n"
    "  }\n"
    "\n"
    "  average /= 9.0;\n"
    "\n"
    "  #ifndef FINAL_DOWN_SAMPLE\n"
    "  gl_FragColor = vec4(average, average, 0.0, 1.0);\n"
    "  #else\n"
    "  gl_FragColor = pack(average);\n"
    "  #endif\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(BRIGHT_PASS)\n"
    "uniform vec2 dsOffsets[4];\n"
    "uniform float brightThreshold;\n"
    "\n"
    "void main() {\n"
    "  vec4 average = vec4(0.0, 0.0, 0.0, 0.0);\n"
    "\n"
    "  average = texture2D(textureSampler, vUV + vec2(dsOffsets[0].x, dsOffsets[0].y));\n"
    "  average += texture2D(textureSampler, vUV + vec2(dsOffsets[1].x, dsOffsets[1].y));\n"
    "  average += texture2D(textureSampler, vUV + vec2(dsOffsets[2].x, dsOffsets[2].y));\n"
    "  average += texture2D(textureSampler, vUV + vec2(dsOffsets[3].x, dsOffsets[3].y));\n"
    "\n"
    "  average *= 0.25;\n"
    "\n"
    "  float luminance = length(average.rgb);\n"
    "\n"
    "  if (luminance < brightThreshold) {\n"
    "  average = vec4(0.0, 0.0, 0.0, 1.0);\n"
    "  }\n"
    "\n"
    "  gl_FragColor = average;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(DOWN_SAMPLE_X4)\n"
    "uniform vec2 dsOffsets[16];\n"
    "\n"
    "void main() {\n"
    "  vec4 average = vec4(0.0, 0.0, 0.0, 0.0);\n"
    "\n"
    "  average = texture2D(textureSampler, vUV + dsOffsets[0]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[1]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[2]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[3]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[4]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[5]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[6]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[7]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[8]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[9]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[10]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[11]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[12]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[13]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[14]);\n"
    "  average += texture2D(textureSampler, vUV + dsOffsets[15]);\n"
    "\n"
    "  average /= 16.0;\n"
    "\n"
    "  gl_FragColor = average;\n"
    "}\n"
    "#endif\n"
    "\n"
    "#if defined(HDR)\n"
    "uniform sampler2D otherSampler;\n"
    "\n"
    "uniform float exposure;\n"
    "uniform float avgLuminance;\n"
    "\n"
    "void main() {\n"
    "  vec4 color = texture2D(textureSampler, vUV) + texture2D(otherSampler, vUV);\n"
    "  vec4 adjustedColor = color / avgLuminance * exposure;\n"
    "\n"
    "  color = adjustedColor;\n"
    "  color.a = 1.0;\n"
    "\n"
    "  gl_FragColor = color;\n"
    "}\n"
    "#endif\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_HDR_FRAGMENT_FX_H
