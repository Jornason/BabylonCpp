#ifndef BABYLON_SHADERS_SHADERS_INCLUDE_PBR_FUNCTIONS_FX_H
#define BABYLON_SHADERS_SHADERS_INCLUDE_PBR_FUNCTIONS_FX_H

namespace BABYLON {

extern const char* pbrFunctions;

const char* pbrFunctions
  = "// Constants\n"
    "#define RECIPROCAL_PI2 0.15915494\n"
    "#define FRESNEL_MAXIMUM_ON_ROUGH 0.25\n"
    "\n"
    "// PBR CUSTOM CONSTANTS\n"
    "const float kPi = 3.1415926535897932384626433832795;\n"
    "const float kRougnhessToAlphaScale = 0.1;\n"
    "const float kRougnhessToAlphaOffset = 0.29248125;\n"
    "\n"
    "float Square(float value)\n"
    "{\n"
    "  return value * value;\n"
    "}\n"
    "\n"
    "float getLuminance(vec3 color)\n"
    "{\n"
    "  return clamp(dot(color, vec3(0.2126, 0.7152, 0.0722)), 0., 1.);\n"
    "}\n"
    "\n"
    "float convertRoughnessToAverageSlope(float roughness)\n"
    "{\n"
    "  // Calculate AlphaG as square of roughness; add epsilon to avoid numerical issues\n"
    "  const float kMinimumVariance = 0.0005;\n"
    "  float alphaG = Square(roughness) + kMinimumVariance;\n"
    "  return alphaG;\n"
    "}\n"
    "\n"
    "// Based on Beckamm roughness to Blinn exponent + http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html \n"
    "float getMipMapIndexFromAverageSlope(float maxMipLevel, float alpha)\n"
    "{\n"
    "  // do not take in account lower mips hence -1... and wait from proper preprocess.\n"
    "  // formula comes from approximation of the mathematical solution.\n"
    "  //float mip = maxMipLevel + kRougnhessToAlphaOffset + 0.5 * log2(alpha);\n"
    "  \n"
    "  // In the mean time \n"
    "  // Always [0..1] goes from max mip to min mip in a log2 way.  \n"
    "  // Change 5 to nummip below.\n"
    "  // http://www.wolframalpha.com/input/?i=x+in+0..1+plot+(+5+%2B+0.3+%2B+0.1+*+5+*+log2(+(1+-+x)+*+(1+-+x)+%2B+0.0005))\n"
    "  float mip = kRougnhessToAlphaOffset + maxMipLevel + (maxMipLevel * kRougnhessToAlphaScale * log2(alpha));\n"
    "  \n"
    "  return clamp(mip, 0., maxMipLevel);\n"
    "}\n"
    "\n"
    "float getMipMapIndexFromAverageSlopeWithPMREM(float maxMipLevel, float alphaG)\n"
    "{\n"
    "  float specularPower = clamp(2. / alphaG - 2., 0.000001, 2048.);\n"
    "  \n"
    "  // Based on CubeMapGen for cosine power with 2048 spec default and 0.25 dropoff \n"
    "  return clamp(- 0.5 * log2(specularPower) + 5.5, 0., maxMipLevel);\n"
    "}\n"
    "\n"
    "// From Microfacet Models for Refraction through Rough Surfaces, Walter et al. 2007\n"
    "float smithVisibilityG1_TrowbridgeReitzGGX(float dot, float alphaG)\n"
    "{\n"
    "  float tanSquared = (1.0 - dot * dot) / (dot * dot);\n"
    "  return 2.0 / (1.0 + sqrt(1.0 + alphaG * alphaG * tanSquared));\n"
    "}\n"
    "\n"
    "float smithVisibilityG_TrowbridgeReitzGGX_Walter(float NdotL, float NdotV, float alphaG)\n"
    "{\n"
    "  return smithVisibilityG1_TrowbridgeReitzGGX(NdotL, alphaG) * smithVisibilityG1_TrowbridgeReitzGGX(NdotV, alphaG);\n"
    "}\n"
    "\n"
    "// Trowbridge-Reitz (GGX)\n"
    "// Generalised Trowbridge-Reitz with gamma power=2.0\n"
    "float normalDistributionFunction_TrowbridgeReitzGGX(float NdotH, float alphaG)\n"
    "{\n"
    "  // Note: alphaG is average slope (gradient) of the normals in slope-space.\n"
    "  // It is also the (trigonometric) tangent of the median distribution value, i.e. 50% of normals have\n"
    "  // a tangent (gradient) closer to the macrosurface than this slope.\n"
    "  float a2 = Square(alphaG);\n"
    "  float d = NdotH * NdotH * (a2 - 1.0) + 1.0;\n"
    "  return a2 / (kPi * d * d);\n"
    "}\n"
    "\n"
    "vec3 fresnelSchlickGGX(float VdotH, vec3 reflectance0, vec3 reflectance90)\n"
    "{\n"
    "  return reflectance0 + (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotH, 0., 1.), 5.0);\n"
    "}\n"
    "\n"
    "vec3 FresnelSchlickEnvironmentGGX(float VdotN, vec3 reflectance0, vec3 reflectance90, float smoothness)\n"
    "{\n"
    "  // Schlick fresnel approximation, extended with basic smoothness term so that rough surfaces do not approach reflectance90 at grazing angle\n"
    "  float weight = mix(FRESNEL_MAXIMUM_ON_ROUGH, 1.0, smoothness);\n"
    "  return reflectance0 + weight * (reflectance90 - reflectance0) * pow(clamp(1.0 - VdotN, 0., 1.), 5.0);\n"
    "}\n"
    "\n"
    "// Cook Torance Specular computation.\n"
    "vec3 computeSpecularTerm(float NdotH, float NdotL, float NdotV, float VdotH, float roughness, vec3 specularColor, vec3 reflectance90)\n"
    "{\n"
    "  float alphaG = convertRoughnessToAverageSlope(roughness);\n"
    "  float distribution = normalDistributionFunction_TrowbridgeReitzGGX(NdotH, alphaG);\n"
    "  float visibility = smithVisibilityG_TrowbridgeReitzGGX_Walter(NdotL, NdotV, alphaG);\n"
    "  visibility /= (4.0 * NdotL * NdotV); // Cook Torance Denominator  integated in viibility to avoid issues when visibility function changes.\n"
    "\n"
    "  vec3 fresnel = fresnelSchlickGGX(VdotH, specularColor, reflectance90);\n"
    "\n"
    "  float specTerm = max(0., visibility * distribution) * NdotL;\n"
    "  return fresnel * specTerm * kPi; // TODO: audit pi constants\n"
    "}\n"
    "\n"
    "float computeDiffuseTerm(float NdotL, float NdotV, float VdotH, float roughness)\n"
    "{\n"
    "  // Diffuse fresnel falloff as per Disney principled BRDF, and in the spirit of\n"
    "  // of general coupled diffuse/specular models e.g. Ashikhmin Shirley.\n"
    "  float diffuseFresnelNV = pow(clamp(1.0 - NdotL, 0.000001, 1.), 5.0);\n"
    "  float diffuseFresnelNL = pow(clamp(1.0 - NdotV, 0.000001, 1.), 5.0);\n"
    "  float diffuseFresnel90 = 0.5 + 2.0 * VdotH * VdotH * roughness;\n"
    "  float diffuseFresnelTerm =\n"
    "  (1.0 + (diffuseFresnel90 - 1.0) * diffuseFresnelNL) *\n"
    "  (1.0 + (diffuseFresnel90 - 1.0) * diffuseFresnelNV);\n"
    "\n"
    "\n"
    "  return diffuseFresnelTerm * NdotL;\n"
    "  // PI Test\n"
    "  // diffuseFresnelTerm /= kPi;\n"
    "}\n"
    "\n"
    "float adjustRoughnessFromLightProperties(float roughness, float lightRadius, float lightDistance)\n"
    "{\n"
    "  #ifdef USEPHYSICALLIGHTFALLOFF\n"
    "  // At small angle this approximation works. \n"
    "  float lightRoughness = lightRadius / lightDistance;\n"
    "  // Distribution can sum.\n"
    "  float totalRoughness = clamp(lightRoughness + roughness, 0., 1.);\n"
    "  return totalRoughness;\n"
    "  #else\n"
    "  return roughness;\n"
    "  #endif\n"
    "}\n"
    "\n"
    "float computeDefaultMicroSurface(float microSurface, vec3 reflectivityColor)\n"
    "{\n"
    "  float kReflectivityNoAlphaWorkflow_SmoothnessMax = 0.95;\n"
    "\n"
    "  float reflectivityLuminance = getLuminance(reflectivityColor);\n"
    "  float reflectivityLuma = sqrt(reflectivityLuminance);\n"
    "  microSurface = reflectivityLuma * kReflectivityNoAlphaWorkflow_SmoothnessMax;\n"
    "\n"
    "  return microSurface;\n"
    "}\n"
    "\n"
    "vec3 toLinearSpace(vec3 color)\n"
    "{\n"
    "  return vec3(pow(color.r, 2.2), pow(color.g, 2.2), pow(color.b, 2.2));\n"
    "}\n"
    "\n"
    "vec3 toGammaSpace(vec3 color)\n"
    "{\n"
    "  return vec3(pow(color.r, 1.0 / 2.2), pow(color.g, 1.0 / 2.2), pow(color.b, 1.0 / 2.2));\n"
    "}\n"
    "\n"
    "#ifdef CAMERATONEMAP\n"
    "  vec3 toneMaps(vec3 color)\n"
    "  {\n"
    "  color = max(color, 0.0);\n"
    "\n"
    "  // TONE MAPPING / EXPOSURE\n"
    "  color.rgb = color.rgb * vCameraInfos.x;\n"
    "\n"
    "  float tuning = 1.5; // TODO: sync up so e.g. 18% greys are matched to exposure appropriately\n"
    "  // PI Test\n"
    "  // tuning *=  kPi;\n"
    "  vec3 tonemapped = 1.0 - exp2(-color.rgb * tuning); // simple local photographic tonemapper\n"
    "  color.rgb = mix(color.rgb, tonemapped, 1.0);\n"
    "  return color;\n"
    "  }\n"
    "#endif\n"
    "\n"
    "#ifdef CAMERACONTRAST\n"
    "  vec4 contrasts(vec4 color)\n"
    "  {\n"
    "  color = clamp(color, 0.0, 1.0);\n"
    "\n"
    "  vec3 resultHighContrast = color.rgb * color.rgb * (3.0 - 2.0 * color.rgb);\n"
    "  float contrast = vCameraInfos.y;\n"
    "  if (contrast < 1.0)\n"
    "  {\n"
    "  // Decrease contrast: interpolate towards zero-contrast image (flat grey)\n"
    "  color.rgb = mix(vec3(0.5, 0.5, 0.5), color.rgb, contrast);\n"
    "  }\n"
    "  else\n"
    "  {\n"
    "  // Increase contrast: apply simple shoulder-toe high contrast curve\n"
    "  color.rgb = mix(color.rgb, resultHighContrast, contrast - 1.0);\n"
    "  }\n"
    "\n"
    "  return color;\n"
    "  }\n"
    "#endif\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_SHADERS_INCLUDE_PBR_FUNCTIONS_FX_H
