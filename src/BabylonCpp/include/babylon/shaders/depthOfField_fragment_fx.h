#ifndef BABYLON_SHADERS_DEPTHOFFIELD_FRAGMENT_FX_H
#define BABYLON_SHADERS_DEPTHOFFIELD_FRAGMENT_FX_H

namespace BABYLON {

extern const char* depthOfFieldPixelShader;

const char* depthOfFieldPixelShader
  = "// BABYLON.JS Depth-of-field GLSL Shader\n"
    "// Author: Olivier Guyot\n"
    "// Does depth-of-field blur, edge blur\n"
    "// Inspired by Francois Tarlier & Martins Upitis\n"
    "\n"
    "// samplers\n"
    "uniform sampler2D textureSampler;\n"
    "uniform sampler2D highlightsSampler;\n"
    "uniform sampler2D depthSampler;\n"
    "uniform sampler2D grainSampler;\n"
    "\n"
    "// uniforms\n"
    "uniform float grain_amount;\n"
    "uniform bool blur_noise;\n"
    "uniform float screen_width;\n"
    "uniform float screen_height;\n"
    "uniform float distortion;\n"
    "uniform bool dof_enabled;\n"
    "//uniform float focus_distance;    // not needed; already used to compute screen distance\n"
    "uniform float screen_distance;    // precomputed screen distance from lens center; based on focal length & desired focus distance\n"
    "uniform float aperture;\n"
    "uniform float darken;\n"
    "uniform float edge_blur;\n"
    "uniform bool highlights;\n"
    "\n"
    "// preconputed uniforms (not effect parameters)\n"
    "uniform float near;\n"
    "uniform float far;\n"
    "\n"
    "// varyings\n"
    "varying vec2 vUV;\n"
    "\n"
    "// constants\n"
    "#define PI     3.14159265\n"
    "#define TWOPI   6.28318530\n"
    "#define inverse_focal_length 0.1  // a property of the lens used\n"
    "\n"
    "// common calculations\n"
    "vec2 centered_screen_pos;\n"
    "vec2 distorted_coords;\n"
    "float radius2;\n"
    "float radius;\n"
    "\n"
    "\n"
    "// on-the-fly constant noise\n"
    "vec2 rand(vec2 co)\n"
    "{\n"
    "  float noise1 = (fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453));\n"
    "  float noise2 = (fract(sin(dot(co, vec2(12.9898, 78.233)*2.0)) * 43758.5453));\n"
    "  return clamp(vec2(noise1, noise2), 0.0, 1.0);\n"
    "}\n"
    "\n"
    "// applies edge distortion on texture coords\n"
    "vec2 getDistortedCoords(vec2 coords) {\n"
    "\n"
    "  if (distortion == 0.0) { return coords; }\n"
    "\n"
    "  vec2 direction = 1.0 * normalize(centered_screen_pos);\n"
    "  vec2 dist_coords = vec2(0.5, 0.5);\n"
    "  dist_coords.x = 0.5 + direction.x * radius2 * 1.0;\n"
    "  dist_coords.y = 0.5 + direction.y * radius2 * 1.0;\n"
    "  float dist_amount = clamp(distortion*0.23, 0.0, 1.0);\n"
    "\n"
    "  dist_coords = mix(coords, dist_coords, dist_amount);\n"
    "\n"
    "  return dist_coords;\n"
    "}\n"
    "\n"
    "// sample screen with an offset (randomize offset angle for better smothness), returns partial sample weight\n"
    "float sampleScreen(inout vec4 color, const in vec2 offset, const in float weight) {\n"
    "\n"
    "  // compute coords with offset (a random angle is added)\n"
    "  vec2 coords = distorted_coords;\n"
    "  float angle = rand(coords * 100.0).x * TWOPI;\n"
    "  coords += vec2(offset.x * cos(angle) - offset.y * sin(angle), offset.x * sin(angle) + offset.y * cos(angle));\n"
    "\n"
    "  color += texture2D(textureSampler, coords)*weight;\n"
    "\n"
    "  return weight;\n"
    "}\n"
    "\n"
    "// returns blur level according to blur size required\n"
    "float getBlurLevel(float size) {\n"
    "  return min(3.0, ceil(size / 1.0));\n"
    "}\n"
    "\n"
    "// returns original screen color after blur\n"
    "vec4 getBlurColor(float size) {\n"
    "\n"
    "  vec4 col = texture2D(textureSampler, distorted_coords);\n"
    "  if (size == 0.0) { return col; }\n"
    "\n"
    "  // there are max. 30 samples; the number of samples chosen is dependant on the blur size\n"
    "  // there can be 10, 20 or 30 samples chosen; levels of blur are then 1, 2 or 3\n"
    "  float blur_level = getBlurLevel(size);\n"
    "\n"
    "  float w = (size / screen_width);\n"
    "  float h = (size / screen_height);\n"
    "  float total_weight = 1.0;\n"
    "  vec2 sample_coords;\n"
    "\n"
    "  total_weight += sampleScreen(col, vec2(-0.50*w, 0.24*h), 0.93);\n"
    "  total_weight += sampleScreen(col, vec2(0.30*w, -0.75*h), 0.90);\n"
    "  total_weight += sampleScreen(col, vec2(0.36*w, 0.96*h), 0.87);\n"
    "  total_weight += sampleScreen(col, vec2(-1.08*w, -0.55*h), 0.85);\n"
    "  total_weight += sampleScreen(col, vec2(1.33*w, -0.37*h), 0.83);\n"
    "  total_weight += sampleScreen(col, vec2(-0.82*w, 1.31*h), 0.80);\n"
    "  total_weight += sampleScreen(col, vec2(-0.31*w, -1.67*h), 0.78);\n"
    "  total_weight += sampleScreen(col, vec2(1.47*w, 1.11*h), 0.76);\n"
    "  total_weight += sampleScreen(col, vec2(-1.97*w, 0.19*h), 0.74);\n"
    "  total_weight += sampleScreen(col, vec2(1.42*w, -1.57*h), 0.72);\n"
    "\n"
    "  if (blur_level > 1.0) {\n"
    "  total_weight += sampleScreen(col, vec2(0.01*w, 2.25*h), 0.70);\n"
    "  total_weight += sampleScreen(col, vec2(-1.62*w, -1.74*h), 0.67);\n"
    "  total_weight += sampleScreen(col, vec2(2.49*w, 0.20*h), 0.65);\n"
    "  total_weight += sampleScreen(col, vec2(-2.07*w, 1.61*h), 0.63);\n"
    "  total_weight += sampleScreen(col, vec2(0.46*w, -2.70*h), 0.61);\n"
    "  total_weight += sampleScreen(col, vec2(1.55*w, 2.40*h), 0.59);\n"
    "  total_weight += sampleScreen(col, vec2(-2.88*w, -0.75*h), 0.56);\n"
    "  total_weight += sampleScreen(col, vec2(2.73*w, -1.44*h), 0.54);\n"
    "  total_weight += sampleScreen(col, vec2(-1.08*w, 3.02*h), 0.52);\n"
    "  total_weight += sampleScreen(col, vec2(-1.28*w, -3.05*h), 0.49);\n"
    "  }\n"
    "\n"
    "  if (blur_level > 2.0) {\n"
    "  total_weight += sampleScreen(col, vec2(3.11*w, 1.43*h), 0.46);\n"
    "  total_weight += sampleScreen(col, vec2(-3.36*w, 1.08*h), 0.44);\n"
    "  total_weight += sampleScreen(col, vec2(1.80*w, -3.16*h), 0.41);\n"
    "  total_weight += sampleScreen(col, vec2(0.83*w, 3.65*h), 0.38);\n"
    "  total_weight += sampleScreen(col, vec2(-3.16*w, -2.19*h), 0.34);\n"
    "  total_weight += sampleScreen(col, vec2(3.92*w, -0.53*h), 0.31);\n"
    "  total_weight += sampleScreen(col, vec2(-2.59*w, 3.12*h), 0.26);\n"
    "  total_weight += sampleScreen(col, vec2(-0.20*w, -4.15*h), 0.22);\n"
    "  total_weight += sampleScreen(col, vec2(3.02*w, 3.00*h), 0.15);\n"
    "  }\n"
    "\n"
    "  col /= total_weight;    // scales color according to weights\n"
    "\n"
    "  // darken if out of focus\n"
    "  if (darken > 0.0) {\n"
    "  col.rgb *= clamp(0.3, 1.0, 1.05 - size*0.5*darken);\n"
    "  }\n"
    "\n"
    "  // blur levels debug\n"
    "  // if(blur_level == 1.0) { col.b *= 0.5; }\n"
    "  // if(blur_level == 2.0) { col.r *= 0.5; }\n"
    "  // if(blur_level == 3.0) { col.g *= 0.5; }\n"
    "\n"
    "  return col;\n"
    "}\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "\n"
    "  // Common calc: position relative to screen center, screen radius, distorted coords, position in texel space\n"
    "  centered_screen_pos = vec2(vUV.x - 0.5, vUV.y - 0.5);\n"
    "  radius2 = centered_screen_pos.x*centered_screen_pos.x + centered_screen_pos.y*centered_screen_pos.y;\n"
    "  radius = sqrt(radius2);\n"
    "  distorted_coords = getDistortedCoords(vUV);    // we distort the screen coordinates (lens \"magnifying\" effect)\n"
    "  vec2 texels_coords = vec2(vUV.x * screen_width, vUV.y * screen_height);  // varies from 0 to SCREEN_WIDTH or _HEIGHT\n"
    "\n"
    "  float depth = texture2D(depthSampler, distorted_coords).r;  // depth value from DepthRenderer: 0 to 1\n"
    "  float distance = near + (far - near)*depth;    // actual distance from the lens\n"
    "  vec4 color = texture2D(textureSampler, vUV);  // original raster\n"
    "\n"
    "\n"
    "  // compute the circle of confusion size (CoC), i.e. blur radius depending on depth\n"
    "  // screen_distance is precomputed in code\n"
    "  float coc = abs(aperture * (screen_distance * (inverse_focal_length - 1.0 / distance) - 1.0));\n"
    "\n"
    "  // disable blur\n"
    "  if (dof_enabled == false || coc < 0.07) { coc = 0.0; }\n"
    "\n"
    "  // blur from edge blur effect\n"
    "  float edge_blur_amount = 0.0;\n"
    "  if (edge_blur > 0.0) {\n"
    "  edge_blur_amount = clamp((radius*2.0 - 1.0 + 0.15*edge_blur) * 1.5, 0.0, 1.0) * 1.3;\n"
    "  }\n"
    "\n"
    "  // total blur amount\n"
    "  float blur_amount = max(edge_blur_amount, coc);\n"
    "\n"
    "  // apply blur if necessary\n"
    "  if (blur_amount == 0.0) {\n"
    "  gl_FragColor = texture2D(textureSampler, distorted_coords);\n"
    "  }\n"
    "  else {\n"
    "\n"
    "  // add blurred color\n"
    "  gl_FragColor = getBlurColor(blur_amount * 1.7);\n"
    "\n"
    "  // if we have computed highlights: enhance highlights\n"
    "  if (highlights) {\n"
    "  gl_FragColor.rgb += clamp(coc, 0.0, 1.0)*texture2D(highlightsSampler, distorted_coords).rgb;\n"
    "  }\n"
    "\n"
    "  if (blur_noise) {\n"
    "  // we put a slight amount of noise in the blurred color\n"
    "  vec2 noise = rand(distorted_coords) * 0.01 * blur_amount;\n"
    "  vec2 blurred_coord = vec2(distorted_coords.x + noise.x, distorted_coords.y + noise.y);\n"
    "  gl_FragColor = 0.04 * texture2D(textureSampler, blurred_coord) + 0.96 * gl_FragColor;\n"
    "  }\n"
    "  }\n"
    "\n"
    "\n"
    "  // apply grain\n"
    "  if (grain_amount > 0.0) {\n"
    "  vec4 grain_color = texture2D(grainSampler, texels_coords*0.003);\n"
    "  gl_FragColor.rgb += (-0.5 + grain_color.rgb) * 0.30 * grain_amount;\n"
    "  }\n"
    "\n"
    "}\n";

} // end of namespace BABYLON

#endif // end of BABYLON_SHADERS_DEPTHOFFIELD_FRAGMENT_FX_H
